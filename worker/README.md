# Worker

工作线程

## 功能

根据Redis传递的消息调用DL4J模型训练，并将结果通过Redis返回给后端。

## 配置

读取YAML文件作为环境配置。目前仅需要配置Redis服务器的主机名和端口号。

## 简述

系统中可以有多个工作线程，后端通过向Redis的`info.skyblond.vovoku.commons.RedisTaskDistributionChannel`
频道中推送`info.skyblond.vovoku.commons.TrainingTaskDistro`的Json消息即可向Worker发起任务。Worker收到消息后以`task.$id`为key试图加锁，锁保证同一时间有唯一的Worker能够竞争到锁，并继续执行，未竞争到锁的Worker将放弃执行本次任务。

竞争到锁之后Worker将试图拉取Prototype，随后利用其中的工厂实例获得DataFetch和DatasetIterator，获取训练需要的数据，数据的位置使用FilePath机制描述。

获取到数据后Worker根据Prototype提供的网络结构配置初始化模型并根据用户提供的参数开始训练。训练顺利结束后Worker会将模型存储在给定的FilePath中，之后将会利用提供的测试集对模型进行评测，最终将测试结果与训练成功的信息一同通过Redis频道返回给后端，后端将根据结果更新模型状态。

以上任务完成后，Worker将释放本任务占用的锁，清理资源，并等待下一个任务的到来。

## 异常情况

对于可捕捉的训练时错误，Worker将捕捉错误，将错误信息和训练失败标志返回给后端，同时清理已经申请的资源，然后等待下一个训练任务。

如发生预料之外未捕捉的错误，对于发生在主线程的异常，将会直接导致主线程结束，进而导致程序退出。一段时间后因为没有刷新锁，后台将检测到本次任务的锁丢失，将模型标记为训练出错。对于发生在Redis任务频道订阅线程的异常，将导致订阅线程退出，Worker不会在收到新的任务，因此不会对系统产生破坏性影响，但需要管理员通过其他方法检测Worker的活跃度来确保Worker没有出现这类异常。对于发生在锁刷新线程中的异常，将会导致本次任务的锁无法继续刷新，继而引发锁失效。但该线程在每次任务时都会重新创建，因此其影响范围只局限于某一次任务，不会影响Worker的其他部分。

在极端情况下，Worker可能成功占用了锁，并且能够一直刷新锁，但用于训练的主线程出于某种原因阻塞，使得训练任务一直无法完成，而Worker也无法主动退出，在后端观测任务锁持续有效，整个任务陷入到了长时间训练的程度。此时管理员需要手动排查出现此错误的Worker。但从程序设计的角度来看，主线程阻塞的情况十分罕见。